<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0-rc1"><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"eterocell.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script><meta name="description" content="The Rust Programming Language (zh-CN)"><meta property="og:type" content="article"><meta property="og:title" content="Rust学习笔记-Day6-错误处理"><meta property="og:url" content="https://eterocell.com/posts/dafbadca/"><meta property="og:site_name" content="EteroConLab"><meta property="og:description" content="The Rust Programming Language (zh-CN)"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-02-01T05:51:04.000Z"><meta property="article:modified_time" content="2023-06-27T03:31:34.752Z"><meta property="article:author" content="Eterocell"><meta property="article:tag" content="笔记"><meta property="article:tag" content="Rust"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://eterocell.com/posts/dafbadca/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://eterocell.com/posts/dafbadca/","path":"posts/dafbadca/","title":"Rust学习笔记-Day6-错误处理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Rust学习笔记-Day6-错误处理 | EteroConLab</title><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;468fdfd2e61b454a9f6c0744c663199f&quot;}"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="EteroConLab" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">EteroConLab</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Art is the imposing of a pattern on experience, and our aesthetic enjoyment is recognition of the pattern. ― Alfred North Whitehead</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li></ul></nav></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#panic-%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">1.1.</span> <span class="nav-text">panic! 与不可恢复的错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-panic-%E7%9A%84-backtrace"><span class="nav-number">1.1.1.</span> <span class="nav-text">使用 panic! 的 backtrace</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#result-%E4%B8%8E%E5%8F%AF%E6%81%A2%E5%A4%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">1.2.</span> <span class="nav-text">Result 与可恢复的错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">匹配不同的错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%B1%E8%B4%A5%E6%97%B6-panic-%E7%9A%84%E7%AE%80%E5%86%99-unwrap-%E5%92%8C-expect"><span class="nav-number">1.2.2.</span> <span class="nav-text">失败时 panic 的简写: unwrap 和 expect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF"><span class="nav-number">1.2.3.</span> <span class="nav-text">传播错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E6%92%AD%E9%94%99%E8%AF%AF%E7%9A%84%E7%AE%80%E5%86%99-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.4.</span> <span class="nav-text">传播错误的简写: ? 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%AF%E8%A2%AB%E7%94%A8%E4%BA%8E%E8%BF%94%E5%9B%9E-result-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text">? 运算符可被用于返回 Result 的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#panic-%E8%BF%98%E6%98%AF%E4%B8%8D-panic"><span class="nav-number">1.3.</span> <span class="nav-text">panic! 还是不 panic!</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-%E4%BB%A3%E7%A0%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E9%83%BD%E9%9D%9E%E5%B8%B8%E9%80%82%E5%90%88-panic"><span class="nav-number">1.3.1.</span> <span class="nav-text">示例, 代码原型和测试都非常适合 panic!</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E6%88%91%E4%BB%AC%E6%AF%94%E7%BC%96%E8%AF%91%E5%99%A8%E7%9F%A5%E9%81%93%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">1.3.2.</span> <span class="nav-text">当我们比编译器知道更多的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99"><span class="nav-number">1.3.3.</span> <span class="nav-text">错误处理指导原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="nav-number">1.3.4.</span> <span class="nav-text">创建自定义类型进行有效性验证</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Eterocell" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Eterocell</p><div class="site-description" itemprop="description">Blog von Eterocell Lab</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Eterocell/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eterocell&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://t.me/Eterocell/" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;Eterocell&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-telegram fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://steamcommunity.com/profiles/76561198107269769/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;profiles&#x2F;76561198107269769&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-steam fa-fw"></i></a> </span><span class="links-of-author-item"><a href="mailto:me@eterocell.com" title="E-Mail → mailto:me@eterocell.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/Eterocell/" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Eterocell&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i></a> </span><span class="links-of-author-item"><a href="https://mastodon.social/@eterocell/" title="Mastodon → https:&#x2F;&#x2F;mastodon.social&#x2F;@eterocell&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-mastodon fa-fw"></i></a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://xkstart.xyz/" title="https:&#x2F;&#x2F;xkstart.xyz&#x2F;" rel="noopener" target="_blank">xkStart</a></li></ul></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://eterocell.com/posts/dafbadca/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Eterocell"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="EteroConLab"><meta itemprop="description" content="Blog von Eterocell Lab"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Rust学习笔记-Day6-错误处理 | EteroConLab"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Rust学习笔记-Day6-错误处理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-02-01 13:51:04" itemprop="dateCreated datePublished" datetime="2021-02-01T13:51:04+08:00">2021-02-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-06-27 11:31:34" itemprop="dateModified" datetime="2023-06-27T11:31:34+08:00">2023-06-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Rust-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Rust 学习笔记</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/">The Rust Programming Language (zh-CN)</a></p><span id="more"></span><h2 id="错误处理">错误处理</h2><p>Rust 将错误组合成两个主要类别: <code>可恢复错误 (recoverable)</code>和 <code>不可恢复错误 (unrecoverable)</code>. 可恢复错误通常代表向用户报告错误和重试操作是合理的情况, 比如未找到文件. 不可恢复错误通常是 bug 的同义词, 比如尝试访问超过数组结尾的位置.</p><p>Rust 并没有异常, 但是, 有可恢复错误 <code>Result&lt;T, E&gt;</code>, 和不可恢复 (遇到错误时停止程序执行) 错误 <code>panic!</code>.</p><h3 id="panic-与不可恢复的错误">panic! 与不可恢复的错误</h3><p>突然有一天, 代码出问题了, 而你对此束手无策. 对于这种情况, Rust 有 <code>panic!</code>宏. 当执行这个宏时, 程序会打印出一个错误信息, 展开并清理栈数据, 然后接着退出. 出现这种情况的场景通常是检测到一些类型的 bug, 而且程序员并不清楚该如何处理它.</p><blockquote><p><strong>对应 panic 时的栈展开或终止</strong></p><p>当出现 panic 时, 程序默认会开始 <strong>展开</strong> (unwinding), 这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据, 不过这个回溯并清理的过程有很多工作. 另一种选择是直接 <strong>终止</strong> (abort), 这会不清理数据就退出程序. 那么程序所使用的内存需要由操作系统来清理. 如果你需要项目的最终二进制文件越小越好, panic 时通过在 <em>Cargo.toml</em> 的 <code>[profile]</code> 部分增加 <code>panic = 'abort'</code>, 可以由展开切换为终止. 例如, 如果你想要在release模式中 panic 时直接终止:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Go brrrr&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;Go brrrr&#x27;, src\main.rs:2:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><h4 id="使用-panic-的-backtrace">使用 panic! 的 backtrace</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Index out of bounds</span></span><br><span class="line">    v[<span class="number">99</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PowerShell</span></span><br><span class="line"><span class="variable">$Env:RUST_BACKTRACE</span>=<span class="number">1</span></span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Windows <span class="built_in">CMD</span></span><br><span class="line"><span class="built_in">set</span> RUST_BACKTRACE=<span class="number">1</span></span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bash</span></span><br><span class="line"><span class="built_in">export</span> RUST_BACKTRACE=1</span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, src\main.rs:4:5</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: std::panicking::begin_panic_handler</span><br><span class="line">             at /rustc/e1884a8e3c3e813aada8254edfa120e85bf5ffca\/library\std\src\panicking.rs:495</span><br><span class="line">   1: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/e1884a8e3c3e813aada8254edfa120e85bf5ffca\/library\core\src\panicking.rs:92</span><br><span class="line">   2: core::panicking::panic_bounds_check</span><br><span class="line">             at /rustc/e1884a8e3c3e813aada8254edfa120e85bf5ffca\/library\core\src\panicking.rs:69</span><br><span class="line">   3: core::slice::index::&#123;&#123;impl&#125;&#125;::index&lt;i32&gt;</span><br><span class="line">             at C:\Users\etero\scoop\persist\rustup\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\slice\index.rs:182</span><br><span class="line">   4: core::slice::index::&#123;&#123;impl&#125;&#125;::index&lt;i32,usize&gt;</span><br><span class="line">             at C:\Users\etero\scoop\persist\rustup\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\slice\index.rs:15</span><br><span class="line">   5: alloc::vec::&#123;&#123;impl&#125;&#125;::index&lt;i32,usize&gt;</span><br><span class="line">             at C:\Users\etero\scoop\persist\rustup\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\alloc\src\vec.rs:1939</span><br><span class="line">   6: vector_test::main</span><br><span class="line">             at .\src\main.rs:4</span><br><span class="line">   7: core::ops::function::FnOnce::call_once&lt;fn(),tuple&lt;&gt;&gt;</span><br><span class="line">             at C:\Users\etero\scoop\persist\rustup\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ops\function.rs:227</span><br><span class="line">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</span><br><span class="line">error: process didn&#x27;t exit successfully: `target\debug\vector_test.exe` (exit code: 101)</span><br></pre></td></tr></table></figure><h3 id="result-与可恢复的错误">Result 与可恢复的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">u32</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src\main.rs:4:18</span><br><span class="line">  |</span><br><span class="line">4 |     let f: u32 = File::open(&quot;hello.txt&quot;);</span><br><span class="line">  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`</span><br><span class="line">  |            |</span><br><span class="line">  |            expected due to this</span><br><span class="line">  |</span><br><span class="line">  = note: expected type `u32`</span><br><span class="line">             found enum `std::result::Result&lt;File, std::io::Error&gt;`   </span><br></pre></td></tr></table></figure><p>错误信息告诉我们了 <code>File::open</code> 函数的返回值类型是 <code>Result&lt;T, E&gt;</code>. 这里泛型参数 <code>T</code> 放入了成功值的类型 <code>std::fs::File</code>, 它是一个文件句柄. <code>E</code> 被用在失败值上时 <code>E</code> 的类型是 <code>std::io::Error</code>.</p><p>这个返回值类型说明 <code>File::open</code> 调用可能会成功并返回一个可以进行读写的文件句柄. 这个函数也可能会失败: 例如, 文件可能并不存在, 或者可能没有访问文件的权限. <code>File::open</code> 需要一个方式告诉我们是成功还是失败, 并同时提供给我们文件句柄或错误信息. 而这些信息正是 <code>Result</code> 枚举可以提供的.</p><p>当 <code>File::open</code> 成功的情况下, 变量 <code>f</code> 的值将会是一个包含文件句柄的 <code>Ok</code> 实例. 在失败的情况下, <code>f</code> 的值会是一个包含更多关于出现了何种错误信息的 <code>Err</code> 实例.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at &#x27;Problem opening the file: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;, src\main.rs:9:13</span><br></pre></td></tr></table></figure><h4 id="匹配不同的错误">匹配不同的错误</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>=&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="失败时-panic-的简写-unwrap-和-expect">失败时 panic 的简写: unwrap 和 expect</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unwrap</code> 的实现就类似于 <code>match</code> 语句. 如果 <code>Result</code> 值是成员 <code>Ok</code>, <code>unwrap</code> 会返回 <code>Ok</code> 中的值. 如果 <code>Result</code> 是成员 <code>Err</code>, <code>unwrap</code> 会为我们调用 <code>panic!</code>.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expect</code> 与 <code>unwrap</code> 的使用方式一样: 返回文件句柄或调用 <code>panic!</code> 宏. <code>expect</code> 用来调用 <code>panic!</code> 的错误信息将会作为参数传递给 <code>expect</code>, 而不像<code>unwrap</code> 那样使用默认的 <code>panic!</code> 信息.</p><h4 id="传播错误">传播错误</h4><p>当编写一个其实现会调用一些可能会失败的操作的函数时, 除了在这个函数中处理错误外, 还可以选择让调用者知道这个错误并决定该如何处理. 这被称为 <code>传播 (propagating)</code> 错误.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的返回值 <code>Result&lt;String, io::Error&gt;</code>, 意味着函数返回一个 <code>Result&lt;T, E&gt;</code> 类型的值, 其中泛型参数 <code>T</code> 的具体类型是 <code>String</code>, 而 <code>E</code> 的具体类型是 <code>io::Error</code>. 如果这个函数没有出任何错误成功返回, 函数的调用者会收到一个包含 <code>String</code> 的 <code>Ok</code> 值 —— 函数从文件中读取到的用户名. 如果函数遇到任何错误, 函数的调用者会收到一个 <code>Err</code> 值, 它储存了一个包含更多这个问题相关信息的 <code>io::Error</code> 实例. 这里选择 <code>io::Error</code> 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：<code>File::open</code> 函数和 <code>read_to_string</code> 方法.</p><p>函数体以 <code>File::open</code> 函数开头. 接着使用 <code>match</code> 处理返回值 <code>Result</code>, <code>match</code> 当 <code>Err</code> 时不再调用 <code>panic!</code>, 而是提早返回并将 <code>File::open</code> 返回的错误值作为函数的错误返回值传递给调用者. 如果 <code>File::open</code> 成功了，我们将文件句柄储存在变量 <code>f</code> 中并继续.</p><p>接着我们在变量 <code>s</code> 中创建了一个新 <code>String</code> 并调用文件句柄 <code>f</code> 的 <code>read_to_string</code> 方法来将文件的内容读取到 <code>s</code> 中. <code>read_to_string</code> 方法也返回一个 <code>Result</code> 因为它也可能会失败: 哪怕是 <code>File::open</code> 已经成功了. 所以我们需要另一个 <code>match</code> 来处理这个 <code>Result</code>: 如果 <code>read_to_string</code> 成功了, 那么这个函数就成功了, 并返回文件中的用户名, 它现在位于被封装进 <code>Ok</code> 的 <code>s</code> 中. 如果 <code>read_to_string</code> 失败了，则像之前处理 <code>File::open</code> 的返回值的 <code>match</code> 那样返回错误值. 不过并不需要显式的调用 <code>return</code>, 因为这是函数的最后一个表达式.</p><p>调用这个函数的代码最终会得到一个包含用户名的 <code>Ok</code> 值, 或者一个包含 <code>io::Error</code> 的 <code>Err</code> 值.</p><h4 id="传播错误的简写-运算符">传播错误的简写: ? 运算符</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件读取到一个字符串是相当常见的操作, 所以 Rust 提供了名为 <code>fs::read_to_string</code> 的函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    fs::<span class="title function_ invoke__">read_to_string</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运算符可被用于返回-result-的函数">? 运算符可被用于返回 Result 的函数</h4><p><code>?</code> 运算符可被用于返回值类型为 <code>Result</code> 的函数, 因为他被定义为与上述 <code>match</code> 表达式有着完全相同的工作方式. <code>match</code> 的 <code>return Err(e)</code> 部分要求返回值类型是 <code>Result</code>, 所以函数的返回值必须是 <code>Result</code> 才能与这个 <code>return</code> 相兼容.</p><p><code>main</code> 函数的一个有效的返回值是 <code>()</code>, 同时出于方便, 另一个有效的返回值是 <code>Result&lt;T, E&gt;</code>, 如下所示:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Box&lt;dyn Error&gt;</code> 被称为 "trait 对象" ("trait object"), 目前可以理解 <code>Box&lt;dyn Error&gt;</code> 为使用 <code>?</code> 时 <code>main</code> 允许返回的 "任何类型的错误".</p><h3 id="panic-还是不-panic"><code>panic!</code> 还是不 <code>panic!</code></h3><h4 id="示例-代码原型和测试都非常适合-panic">示例, 代码原型和测试都非常适合 <code>panic!</code></h4><p>当你编写一个示例来展示一些概念时, 在拥有健壮的错误处理代码的同时也会使得例子不那么明确. 例如, 调用一个类似 <code>unwrap</code> 这样可能 <code>panic!</code> 的方法可以被理解为一个你实际希望程序处理错误方式的占位符, 它根据其余代码运行方式可能会各不相同.</p><p>类似地, 在我们准备好决定如何处理错误之前, <code>unwrap</code> 和 <code>expect</code> 方法在原型设计时非常方便. 当我们准备好让程序更加健壮时, 它们会在代码中留下清晰的标记.</p><p>如果方法调用在测试中失败了, 我们希望这个测试都失败, 即便这个方法并不是需要测试的功能. 因为 <code>panic!</code> 会将测试标记为失败, 此时调用 <code>unwrap</code> 或 <code>expect</code> 是恰当的.</p><h4 id="当我们比编译器知道更多的情况">当我们比编译器知道更多的情况</h4><p>当你有一些其他的逻辑来确保 <code>Result</code> 会是 <code>Ok</code> 值时, 调用 <code>unwrap</code> 也是合适的, 虽然编译器无法理解这种逻辑. 你仍然需要处理一个 <code>Result</code> 值: 即使在你的特定情况下逻辑上是不可能的, 你所调用的任何操作仍然有可能失败. 如果通过人工检查代码来确保永远也不会出现 <code>Err</code> 值, 那么调用 <code>unwrap</code> 也是完全可以接受的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><h4 id="错误处理指导原则">错误处理指导原则</h4><p>在当有可能会导致有害状态的情况下建议使用 <code>panic!</code> —— 在这里, 有害状态是指当一些假设, 保证, 协议或不可变性被打破的状态, 例如无效的值, 自相矛盾的值或者被传递了不存在的值 —— 外加如下几种情况:</p><ul><li>有害状态并不包含 <strong>预期</strong> 会偶尔发生的错误</li><li>在此之后代码的运行依赖于不处于这种有害状态</li><li>当没有可行的手段来将有害状态信息编码进所使用的类型中的情况</li></ul><p>当错误预期会出现时, 返回 <code>Result</code> 仍要比调用 <code>panic!</code> 更为合适.</p><p>当代码对值进行操作时, 应该首先验证值是有效的, 并在其无效时 <code>panic!</code>.</p><h4 id="创建自定义类型进行有效性验证">创建自定义类型进行有效性验证</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">        value: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">            <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Guess &#123; value &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Eterocell</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://eterocell.com/posts/dafbadca/" title="Rust学习笔记-Day6-错误处理">https://eterocell.com/posts/dafbadca/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><span>欢迎关注我的其它发布渠道</span><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://twitter.com/Eterocell/"><span class="icon"><i class="fab fa-twitter"></i> </span><span class="label">Twitter</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="https://t.me/EteroGarten/"><span class="icon"><i class="fab fa-telegram"></i> </span><span class="label">Telegram</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="https://mastodon.social/@eterocell/"><span class="icon"><i class="fab fa-mastodon"></i> </span><span class="label">Mastodon</span></a></div></div></div><div class="post-tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a> <a href="/tags/Rust/" rel="tag"><i class="fa fa-tag"></i> Rust</a></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i></i> </span><span class="author" itemprop="copyrightHolder">Eterocell</span></div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a href="https://github.com/Eterocell" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>