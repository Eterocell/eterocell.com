<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android NDK r27 Clang 18 Hikari 混淆器 LLVM Pass 插件加载方案</title>
    <url>/posts/7dbf3410/</url>
    <content><![CDATA[<h2 id="要用到的项目及说明">要用到的项目及说明</h2>
<ul>
<li><p><a
href="https://github.com/61bcdefg/Hikari-LLVM15-Core">Hikari-LLVM15-Core</a>:
Obfuscator source code (Working on LLVM 18, Don't be confused by its
project name)</p></li>
<li><p><a
href="https://github.com/61bcdefg/Hikari-LLVM15-Headers">Hikari-LLVM15-Headers</a>:
Obfuscator headers</p></li>
<li><p><a
href="https://android.googlesource.com/platform/prebuilts/clang/host/darwin-x86/+log/refs/heads/master/clang-r522817">Android
Prebuilt Clang r522817</a>: NDK r27 使用的 clang revision 为 r522817 (见
<code>$ANDROID_SDK_ROOT/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/AndroidVersion.txt</code>)</p></li>
<li><p><a
href="https://android.googlesource.com/platform/prebuilts/clang/host/darwin-x86/+/1c8f09d76cb556336e677ef21111c1d7b20775e4/clang-r522817/">clang-r522817
tarball</a>: 预编译 clang 工具链</p></li>
<li><p><a
href="https://android.googlesource.com/toolchain/llvm-project">Android
llvm-project</a>: NDK r27 的 revision 为
d8003a456d14a3deb8054cdaa529ffbf02d9b262 (见
<code>$ANDROID_SDK_ROOT/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang --version</code>)</p></li>
<li><p>仅在 arm64 的 macOS 14 上进行了测试, 在 macOS x86_64 及 Linux
上应该是通用的, Windows 上不可用.</p></li>
</ul>
<span id="more"></span>
<h2 id="混淆器-llvm-pass-插件构建">混淆器 LLVM Pass 插件构建</h2>
<p>要编译一个独立的 Hikari LLVM Pass 插件, 可参考如下项目结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── Hikari</span><br><span class="line">│         ├── AntiClassDump.cpp</span><br><span class="line">│         ├── AntiDebugging.cpp</span><br><span class="line">│         ├── AntiHooking.cpp</span><br><span class="line">│         ├── BogusControlFlow.cpp</span><br><span class="line">│         ├── CMakeLists.txt</span><br><span class="line">│         ├── ConstantEncryption.cpp</span><br><span class="line">│         ├── CryptoUtils.cpp</span><br><span class="line">│         ├── Flattening.cpp</span><br><span class="line">│         ├── FunctionCallObfuscate.cpp</span><br><span class="line">│         ├── FunctionWrapper.cpp</span><br><span class="line">│         ├── IndirectBranch.cpp</span><br><span class="line">│         ├── LICENSE</span><br><span class="line">│         ├── Obfuscation.cpp</span><br><span class="line">│         ├── PluginEntry.cpp</span><br><span class="line">│         ├── README.md</span><br><span class="line">│         ├── SplitBasicBlocks.cpp</span><br><span class="line">│         ├── StringEncryption.cpp</span><br><span class="line">│         ├── SubstituteImpl.cpp</span><br><span class="line">│         ├── Substitution.cpp</span><br><span class="line">│         ├── Utils.cpp</span><br><span class="line">│         ├── include</span><br><span class="line">│         │         └── llvm</span><br><span class="line">│         │             └── Transforms</span><br><span class="line">│         │                 └── Obfuscation</span><br><span class="line">│         │                     ├── AntiClassDump.h</span><br><span class="line">│         │                     ├── AntiDebugging.h</span><br><span class="line">│         │                     ├── AntiHook.h</span><br><span class="line">│         │                     ├── BogusControlFlow.h</span><br><span class="line">│         │                     ├── ConstantEncryption.h</span><br><span class="line">│         │                     ├── CryptoUtils.h</span><br><span class="line">│         │                     ├── Flattening.h</span><br><span class="line">│         │                     ├── FunctionCallObfuscate.h</span><br><span class="line">│         │                     ├── FunctionWrapper.h</span><br><span class="line">│         │                     ├── IndirectBranch.h</span><br><span class="line">│         │                     ├── LICENSE</span><br><span class="line">│         │                     ├── Obfuscation.h</span><br><span class="line">│         │                     ├── README.md</span><br><span class="line">│         │                     ├── Split.h</span><br><span class="line">│         │                     ├── StringEncryption.h</span><br><span class="line">│         │                     ├── SubstituteImpl.h</span><br><span class="line">│         │                     ├── Substitution.h</span><br><span class="line">│         │                     ├── Utils.h</span><br><span class="line">│         │                     └── compat</span><br><span class="line">│         │                         └── CallSite.h</span><br><span class="line">│         └── json.hpp</span><br><span class="line">└── clang-r522817</span><br><span class="line">          └── ......</span><br></pre></td></tr></table></figure>
<p>将 Hikari-LLVM15-Core 放在 ./Hikari 目录下, Hikari-LLVM15-Headers
放在 ./Hikari/include/llvm/Transforms/Obfuscation 下,
这样可以尽可能减少对原项目源码的修改.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"><span class="keyword">project</span>(Hikari-Obf-LLVM18-NDK27)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set(CMAKE_OSX_ARCHITECTURES x86_64)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_OSX_ARCHITECTURES arm64)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/clang-r522817/bin/clang)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/clang-r522817/bin/clang++)</span><br><span class="line"><span class="keyword">set</span>(ENV&#123;LLVM_HOME&#125; <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/clang-r522817)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;$LLVM_HOME is not defined&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">set</span>(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib/cmake/llvm)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(LLVM REQUIRED CONFIG)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LLVM_LIBRARY_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment this for macOS arm64</span></span><br><span class="line"><span class="keyword">add_compile_definitions</span>(ENDIAN_LITTLE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SKIP_RPATH <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(Hikari)</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./Hikari/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(Hikari MODULE</span><br><span class="line">        FunctionCallObfuscate.cpp</span><br><span class="line">        CryptoUtils.cpp</span><br><span class="line">        BogusControlFlow.cpp</span><br><span class="line">        SubstituteImpl.cpp</span><br><span class="line">        Substitution.cpp</span><br><span class="line">        Flattening.cpp</span><br><span class="line">        Utils.cpp</span><br><span class="line">        SplitBasicBlocks.cpp</span><br><span class="line">        AntiClassDump.cpp</span><br><span class="line">        AntiDebugging.cpp</span><br><span class="line">        AntiHooking.cpp</span><br><span class="line">        StringEncryption.cpp</span><br><span class="line">        IndirectBranch.cpp</span><br><span class="line">        FunctionWrapper.cpp</span><br><span class="line">        ConstantEncryption.cpp</span><br><span class="line">        Obfuscation.cpp</span><br><span class="line">        PluginEntry.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(Hikari PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># LLVM is (typically) built with no C++ RTTI. We need to match that;</span></span><br><span class="line"><span class="comment"># otherwise, we&#x27;ll get linker errors about missing RTTI data.</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(Hikari PROPERTIES</span><br><span class="line">        COMPILE_FLAGS <span class="string">&quot;-fno-rtti&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get proper shared-library behavior (where symbols are not necessarily</span></span><br><span class="line"><span class="comment"># resolved when the shared library is linked) on OS X.</span></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    <span class="keyword">set_target_properties</span>(Hikari PROPERTIES</span><br><span class="line">            LINK_FLAGS <span class="string">&quot;-undefined dynamic_lookup&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span> (APPLE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">        <span class="keyword">COMMAND</span> git log -<span class="number">1</span> --format=%H</span><br><span class="line">        WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span></span><br><span class="line">        OUTPUT_VARIABLE HIKARI_GIT_COMMIT_HASH</span><br><span class="line">        OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(Hikari PRIVATE <span class="string">&quot;-DGIT_COMMIT_HASH=\&quot;$&#123;HIKARI_GIT_COMMIT_HASH&#125;\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>相比 Hikari-LLVM15-Core 原项目, LLVM pass plugin
还需要添加一个插件入口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./Hikari/PluginEntry.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Passes/PassBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Passes/PassPlugin.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Transforms/Obfuscation/Obfuscation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LLVM_VERSION_MAJOR &gt;= 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> llvm &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">PassPluginLibraryInfo <span class="title">getHikariPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;Hikari&quot;</span>, LLVM_VERSION_STRING,</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerPipelineStartEPCallback</span>(</span><br><span class="line">                [](ModulePassManager &amp;PM, OptimizationLevel) &#123;</span><br><span class="line">                  PM.<span class="built_in">addPass</span>(<span class="built_in">ObfuscationPass</span>());</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">LLVM_ATTRIBUTE_WEAK PassPluginLibraryInfo <span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getHikariPluginInfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace llvm</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="构建混淆插件">构建混淆插件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p build</span><br><span class="line">pushd build</span><br><span class="line">cmake -G Ninja -DCMAKE_BUILD_TYPE=MinSizeRel ../</span><br><span class="line">cmake --build .</span><br><span class="line">popd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建出的 libHikari.so 在 ./build/Hikari 目录下</span></span><br></pre></td></tr></table></figure>
<p>构建时可能遇到的两种问题:</p>
<ol type="1">
<li><p>CMake 报错:</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at clang-r522817-darwin-x86_64/lib/cmake/llvm/LLVMExports.cmake:1238 (message):</span><br><span class="line">The imported target &quot;LLVMDemangle&quot; references the file</span><br><span class="line"></span><br><span class="line">    &quot;$(OBF_PROJECT_DIR)/clang-r522817/lib/libLLVMDemangle.a&quot;</span><br><span class="line"></span><br><span class="line">but this file does not exist.  Possible reasons include:</span><br><span class="line"></span><br><span class="line">* The file was deleted, renamed, or moved to another location.</span><br><span class="line"></span><br><span class="line">* An install or uninstall procedure did not complete successfully.</span><br><span class="line"></span><br><span class="line">* The installation package was faulty and contained</span><br></pre></td></tr></table></figure></p>
<p>在 $(OBF_PROJECT_DIR)/clang-r522817/lib/cmake/llvm/LLVMExports.cmake
中找到以下脚本, 注释即可:</p>
<p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Loop over all imported files and verify that they actually exist</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">target</span> <span class="variable">$&#123;_IMPORT_CHECK_TARGETS&#125;</span> )</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">file</span> <span class="variable">$&#123;_IMPORT_CHECK_FILES_FOR_$&#123;target&#125;</span>&#125; )</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;file&#125;&quot;</span> )</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span></span><br><span class="line"><span class="string">\&quot;$&#123;file&#125;\&quot;</span></span><br><span class="line"><span class="string">but this file does not exist.  Possible reasons include:</span></span><br><span class="line"><span class="string">* The file was deleted, renamed, or moved to another location.</span></span><br><span class="line"><span class="string">* An install or uninstall procedure did not complete successfully.</span></span><br><span class="line"><span class="string">* The installation package was faulty and contained</span></span><br><span class="line"><span class="string">\&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;\&quot;</span></span><br><span class="line"><span class="string">but not all the files it references.</span></span><br><span class="line"><span class="string">&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">unset</span>(_IMPORT_CHECK_FILES_FOR_<span class="variable">$&#123;target&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">unset</span>(_IMPORT_CHECK_TARGETS)</span><br></pre></td></tr></table></figure></p></li>
<li><p>(macOS) 构建时报类似于 clang-18 已损坏:
<code>sudo xattr -d com.apple.quarantine $(OBF_PROJECT_DIR)/clang-r522817/bin/*</code></p></li>
</ol>
<h2 id="ndk-clang-工具链的改动">NDK Clang 工具链的改动</h2>
<p>如果直接用原版 NDK 加载 libHikari, 可能会遇到以下三种问题:</p>
<ol type="1">
<li><p>(macOS) clang 和 libHikari.so 签名不一致导致被 Hardened Runtime
拒绝加载:
<code>error: unable to load plugin 'libHikari.so': 'dlopen(libHikari.so, 0x0009): tried: 'libHikari.so' (code signature in &lt;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&gt; 'libHikari.so' not valid for use in process: mapping process and mapped file (non-platform) have different Team IDs), '/System/Volumes/Preboot/Cryptexes/OSlibHikari.so' (no such file), 'libHikari.so' (code signature in &lt;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&gt; 'libHikari.so' not valid for use in process: mapping process and mapped file (non-platform) have different Team IDs)'</code>
需要将 llvm/bin 中的可执行文件与 libHikari.so 用同一苹果开发者 TeamID
签名:</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sign_macho() &#123;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Directory to search <span class="keyword">for</span> Mach-O executables</span></span><br><span class="line">local directory=&quot;$1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Signing identity</span></span><br><span class="line">local signing_identity=&quot;$TeamID&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Find and sign all Mach-O executables</span></span><br><span class="line">find &quot;$directory&quot; -type f -perm +111 | while read -r file; do</span><br><span class="line">    # Check if the file is a Mach-O executable</span><br><span class="line">    if file &quot;$file&quot; | grep -q &quot;Mach-O&quot;; then</span><br><span class="line">    echo &quot;Signing $file&quot;</span><br><span class="line">    codesign -s &quot;$signing_identity&quot; -f &quot;$file&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Signing process completed.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>找不到符号:
<code>error: unable to load plugin '$(PROJECT_DIR)/app/obf_lib/darwin_arm64/libHikari.so': 'dlopen($(PROJECT_DIR)/app/obf_lib/darwin_arm64/libHikari.so, 0x0009): symbol not found in flat namespace '__ZTVN4llvm2cl6OptionE''</code>.
这是由于官方 NDK 中自带的 clang 二进制符号不完整导致的. 需要自行构建
Android LLVM 来获取完整的 <code>clang-18</code>, <code>clang</code>,
<code>clang++</code> 替换掉 NDK 内自带的对应的三个文件.</p></li>
</ol>
<h3 id="构建-android-llvm-project">构建 Android llvm-project</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://android.googlesource.com/toolchain/llvm-project</span><br><span class="line">cd llvm-project</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确保与原版 NDK 相同的</span></span><br><span class="line">git checkout d8003a456d14a3deb8054cdaa529ffbf02d9b262</span><br><span class="line">cd ..</span><br><span class="line">mkdir -p build</span><br><span class="line">cd build</span><br><span class="line"></span><br><span class="line">cmake -G &quot;Ninja&quot; ../llvm-project/llvm \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=&quot;./llvm_x64&quot; \</span><br><span class="line">    -DCMAKE_CXX_STANDARD=17 \</span><br><span class="line">    -DCMAKE_BUILD_TYPE=MinSizeRel </span><br><span class="line">    -DLLVM_APPEND_VC_REV=on \</span><br><span class="line">    -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra;compiler-rt;lld;mlir;openmp;polly;&quot; \</span><br><span class="line">    -DLLVM_ENABLE_RUNTIMES=&quot;libcxx;libcxxabi;libunwind&quot; \</span><br><span class="line">    -DLLVM_TARGETS_TO_BUILD=&quot;X86;ARM;AArch64&quot; \</span><br><span class="line">    -DLLVM_INSTALL_UTILS=ON \</span><br><span class="line">    -DLLVM_INCLUDE_TESTS=OFF \</span><br><span class="line">    -DLLVM_BUILD_TESTS=OFF \</span><br><span class="line">    -DLLVM_INCLUDE_BENCHMARKS=OFF \</span><br><span class="line">    -DLLVM_BUILD_BENCHMARKS=OFF \</span><br><span class="line">    -DLLVM_INCLUDE_EXAMPLES=OFF \</span><br><span class="line">    -DLLVM_ENABLE_BACKTRACES=OFF \</span><br><span class="line">    -DLLVM_BUILD_DOCS=OFF</span><br><span class="line"></span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>
<p>构建完成后, 可以将原有的 NDK 复制一份出来专门用于混淆:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $ANDROID_SDK_ROOT/ndk</span><br><span class="line">cp -r 27.0.12077973 27.0.12077973-obf</span><br><span class="line">cd 27.0.12077973-obf/toolchains/llvm/prebuilt/darwin-x86_64/bin</span><br><span class="line">mv clang clang.bak</span><br><span class="line">mv clang++ clang++.bak</span><br><span class="line">mv clang-18 clang-18.bak</span><br></pre></td></tr></table></figure>
<p>再将构建获得的 <code>clang</code>, <code>clang++</code>,
<code>clang-18</code> 放到该目录下即可.</p>
<h2 id="加载混淆器-llvm-pass-插件-传递混淆参数">加载混淆器 LLVM Pass
插件, 传递混淆参数</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle.kts</span></span><br><span class="line">android &#123;</span><br><span class="line">    ndkVersion = <span class="string">&quot;27.0.12077973&quot;</span></span><br><span class="line">    ndkPath = <span class="string">&quot;<span class="variable">$ANDROID_SDK_ROOT</span>/ndk/27.0.12077973-obf&quot;</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                <span class="comment">// 混淆插件路径</span></span><br><span class="line">                <span class="keyword">val</span> obfLibDir =</span><br><span class="line">                    <span class="string">&quot;<span class="subst">$&#123;project.layout.projectDirectory.asFile.absolutePath&#125;</span>/obf_lib/darwin_arm64/libHikari.so&quot;</span></span><br><span class="line">                <span class="keyword">val</span> obfArgs = listOf(</span><br><span class="line">                    <span class="string">&quot;-fvisibility=hidden&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;-fpass-plugin=<span class="variable">$obfLibDir</span>&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;-Xclang&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;-load&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;-Xclang&quot;</span>,</span><br><span class="line">                    obfLibDir,</span><br><span class="line">                    <span class="comment">// 混淆参数, 请自行参考 Hikari-LLVM15-Core 原项目配置</span></span><br><span class="line">                    <span class="string">&quot;-mllvm&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;-enable-allobf&quot;</span></span><br><span class="line">                )</span><br><span class="line">                cppFlags += obfArgs</span><br><span class="line">                cFlags += obfArgs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果对比">结果对比</h2>
<figure>
<img src="size.png" alt="so 大小" />
<figcaption aria-hidden="true">so 大小</figcaption>
</figure>
<figure>
<img src="hopper.png" alt="未混淆" />
<figcaption aria-hidden="true">未混淆</figcaption>
</figure>
<figure>
<img src="hopper_obf.png" alt="混淆后" />
<figcaption aria-hidden="true">混淆后</figcaption>
</figure>
<h2 id="致谢">致谢</h2>
<ul>
<li><a href="https://xtuly.cn/article/ndk-load-llvm-pass-plugin">NDK
加载 LLVM Pass 方案 | Ylarod’s Blog</a> -
本方案的绝大多数思路来源于该篇文章, 仅针对 NDK r27 做了调整.</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Obfuscator</tag>
      </tags>
  </entry>
  <entry>
    <title>一次 Git 将 jar 误认为文本文件自动替换换行符引发的血案</title>
    <url>/posts/ce8d81c3/</url>
    <content><![CDATA[<p>早上起来 Renovate 提 PR 帮我把 Gradle 更新到了 8.5, 我并没有看为什么
CI 报错直接合了, 毕竟 Gradle 从 8.4 更新到 8.5
大概率不会出现什么大问题可以合了之后再改, 只不过,,,:</p>
<span id="more"></span>
<figure>
<img src="failed_commits.png" alt="Failed Commits" />
<figcaption aria-hidden="true">Failed Commits</figcaption>
</figure>
<p>报错的详情为
<code>Error: Could not find or load main class org.gradle.wrapper.GradleWrapperMain</code>,
因此大概率是运行 <code>./gradlew</code> 时,
<code>./gradle/wrapper/gradle-wrapper.jar</code> 有问题. 果然拉回本地后,
第一次 <code>./gradlew</code> 报了同样的错, 删除 <code>./gradlew</code>,
<code>./gradlew.bat</code>,
<code>./gradle/wrapper/gradle-wrapper.jar</code> 之后运行
<code>gradle wrapper --gradle-version 8.5 --distribution-type all</code>
后再次运行 <code>./gradlew</code> 就可以了. 果断 add, commit 再 push,
于是再次报了
<code>Error: Could not find or load main class org.gradle.wrapper.GradleWrapperMain</code>.</p>
<p>之后尝试了很多, 包括 revert 前面升级 actions/setup-java 的 commit,
去掉 actions.yml 中保留 Gradle 缓存的步骤等. 但唯一有效的是 revert 升级
Gradle 的 commit.</p>
<p>机缘巧合下, 在 actions 中添加 gradle/wrapper-validation-action 后,
报错为 <code>./gradle/wrapper/gradle-wrapper.jar</code> 的 sha256
的校验和为 <code>c7b7b1c</code> 开头而非预期的 <code>d3b261c</code> 开头
(<a href="https://gradle.org/release-checksums/">可以再这里找到 Gradle
各版本 bin, all 和 wrapper jar 的 sha256 checksum</a>),
但我本地的校验和又是正确的. 于是删除本地重新拉远程,
发现远程的校验和确实是错误的, 于是又重新拉 Gradle wrapper, 本地确认
sha256 校验和无误后 commit 上传, 但 CI 仍然报错误校验和. 但发现在 commit
的时候报了这个警告:
<code>warning: CRLF will be replaced by LF in gradle/wrapper/gradle-wrapper.jar</code>.
校验和对不上的原因算是找到了, 于是在 .gitattributes 中添加
<code>*.jar -text</code> 规则, 再重新拉 Gradle wrapper commit push
就正常了.</p>
<p>咱也不知道为啥 Git 把 gradle-wrapper.jar 认成了文本文件修改其换行符,
不过以后 gradle/wrapper-validation-action 和 <code>*.jar -txt</code>
大概会在我的 Actions 和 .gitattributes 中常驻了...</p>
<h3 id="reference">Reference</h3>
<ul>
<li><a
href="https://docs.gradle.org/current/userguide/gradle_wrapper.html#configuring_checksum_verification">Gradle
Wrapper Reference - Configuring Checksum Verification</a></li>
</ul>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
